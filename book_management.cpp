#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include"book_management.h"
#include"interface.h"

pbook bookhead = NULL;//创建头指针，初始值为NULL


//saves the database of books in the specified file
//returns 0 if books were stored correctly, or an error code otherwise
int store_books(FILE *file) 
{
	int a;
	pbook sbook = bookhead ;
	file=fopen("bookfile","w+");   //以读写方式打开名字为bookfile的二进制文件，同时清空文件原本内容 
	if(file==NULL)
	{
		printf("file can't be opened");
		return 1; 
	}
	if (sbook==NULL){
		return 1;//链表还为空，没有书籍需要存入文件 
	}
	while(sbook!=NULL){
		a=fwrite(sbook,sizeof(struct _Book),1,file);//将链表中的内容内容存入file所指向的文件中
		if(a!=1)   
		{
			printf("An error occurred while writing to the file");
			return 1;
		}
		sbook = sbook->nextbook; 	
	}
	fclose(file);    //关闭文件
	return 0;	
} 


//loads the database of books from the specified file
//the file must have been generated by a previous call to store_books()
//returns 0 if books were loaded correctly, or an error code otherwise
int load_books(FILE *file){
	file=fopen("bookfile","ab+");  //打开文件
	pbook bookpa = NULL, bookpb = NULL, bookpc = NULL;
	if(file==NULL)
	{
		printf("the file can not be opened successfully\n");
		return 1;
	}
	while(!feof(file))        //判断读写标志是否移到文件末尾 
	{
	    bookpa=(pbook)malloc(sizeof(Book)); //用malloc在内存申请一段空间 
	   fread(bookpa,sizeof(struct _Book),1,file);     //将file所指向文件的内容传递给bookpa 
	   if(bookhead==NULL)
	   {
	      bookhead=bookpa;
	      bookpb=bookpa;
	    }
	    else             //建立链表 
	    {
	    	bookpc=bookpb;
	    	bookpb->nextbook=bookpa;
	    	bookpb=bookpa;
		}
    }
    if(bookpc!=NULL)  	//文件里没有数据 
       bookpc->nextbook=NULL;
    else
       bookhead=NULL;
    fclose(file);    //关闭文件
	return 0; 
}


//adds a book to the ones available to the library
//returns 0 if the book could be added, or an error code otherwise
int add_book(Book book)
{
	do
	{
		pbook padd = NULL, bookpr = bookhead;
		FILE *file;    //指向文件的指针 
		int s,f;
		padd=(pbook)malloc(sizeof(Book));//申请内存空间
		if(padd == NULL){			//如果申请内存失败，则添加book失败，返回1 
			printf("memory allocation failed\n");
			return 1;
		}
		if(bookhead == NULL){ //如果头指针是NULL,说明可以从头添加节点 
			bookhead = padd;
		}else{
			while(bookpr->nextbook!= NULL){
					bookpr = bookpr->nextbook;
			}
			bookpr->nextbook = padd;
		}
		//添加图书信息
		printf(" Please input BOOK id ");    
		scanf("%s",&padd->id);
		printf(" Please input BOOK title ");
		scanf("%s",&padd->title);
		printf("Please input BOOK authors");
		scanf("%s",&padd->authors);
		printf("Please input Year of publication");
		scanf("%s",&padd->year);
		printf("Please input the number of copies of the book\n");
		scanf("%s",&padd->copies);
		padd->nextbook = NULL;//新增的节点位于链表末端，所以为null 
		system("pause");
		printf("|                                              |");
		printf("| Saved successfully. Do you want to continue  |");
		printf("| 1.YES                                    2.NO|\n"); 
		scanf("%d",&s);
		do{
			if(s=='1')
			{
				break;
			}	 
			else if(s=='2')
			{
				return 0;
			}			
		 }while(1);  
	}while(1);
}

//removes a book from the library
//returns 0 if the book could be successfully removed, or an error code otherwise.
int remove_book(Book book){
	do
	{
		system("cls");
		FILE *file1;
		int aj=0,ax,ai=11,tt,uu;
		char title[20];
		char at,ac;
		int ach,iD; 
		pbook premove = NULL , preremove = NULL, p1 = NULL, p2 = NULL;
		premove = bookhead;
		setxy(50,9);
		printf("请输入你要删除的图书的书名：");
		scanf("%s",title);
		setxy(19,6);
		printf("**********************图书信息******************************");
		setxy(19,9);
		printf("------------------------------------------------------------");
		setxy(19,10);
		printf(" ID        Title        authors         years        copies ");
		setxy(19,11);
		printf("------------------------------------------------------------");
		while(premove!=NULL)
		{
			if(premove!=NULL&&strcmp(premove->title,title)==0)//strcmp用于检验字符串是否相同 
			{
				setxy(20,ai);
				aj++;
				printf("%d:%d%20s%20s%d   %d   \n",aj,premove->id,premove->title,premove->authors,premove->year,premove->copies);
				ai++;
			}
			premove=premove->nextbook;
		}
		if(aj==0)                   //如果aj=0，说明没有进入前面的循环，也就是相应的信息没有被找到 
		{ 
			setxy(50,ai);
			printf("没有找到相应的信息！(按0返回，按1重新搜索)");
			while(1)               //用死循环防止除0和1的其他按键干扰 
			{
				scanf("%d",&ach);
				if(ach==0)
				{
					Mainmenu();
					break;
				}
				else if(ach==1)
				{
					break;
				}
			}
			if(ach==1)     //如果输入的ach等于1，结束本次循环 
			   continue;
		}
		while(1)
		{
			setxy(46,ai);
			printf("请输入您要删除的图书的ID：");
			scanf("%d",&iD);
			p1=bookhead;
			while(1)
			{
				
				if(p1->id==iD&&strcmp(premove->title,title)==0){
					break;
				}
				else{
					p1=p1->nextbook;
				}
				if(p1==NULL){
					setxy(46,++ai);
					printf("Input error, please input again!");//输入有错误，提醒用户重新输入
					break;
				}
			}
		}
		setxy(47,9);
		printf("-------------------------");
		setxy(47,10);
		printf("|                       |");
		setxy(47,11);
		printf("|     是否确认删除？    |");
		setxy(47,13);
		printf("| 1.是             2.否 |");
		setxy(47,14);
		printf("|                       |");
		setxy(47,15);
		printf("-------------------------");
		while(1)
		{
			scanf("%d",&tt);
			if(tt==1)
			{
				break;
			} 
			else if(tt==2)
			{
				return 1;
			}
		} 
		premove=bookhead;
		while(premove!=NULL&&premove->id!=iD)
		{
			preremove=premove;
			premove=premove->nextbook;
		}
		if(premove!=NULL)
		{
			if(preremove==NULL)
			{
				bookhead=bookhead->nextbook;
			}
			else
			{
				preremove->nextbook=premove->nextbook;
			}
		}
		free(premove);
		store_books(file1);
		system("cls");
		setxy(47,8);
		printf("-------------------------");
		setxy(47,9);
		printf("|                       |");
		setxy(47,10);
		printf("|  删除成功，是否继续？ |");
		setxy(47,12);
		printf("| 1.是             2.否 |");
		setxy(47,13);
		printf("|                       |");
		setxy(47,14);
		printf("-------------------------");
		while(1)
		{
			scanf("%d",&uu);
			if(uu==1)
			{
				break;
			}
			else if(uu==2)
			{
				return 0;
			}
		}
	}while(1);
} 


//finds books with a given title.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_title (const char *title);

//finds books with the given authors.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_author (const char *author);

//finds books published in the given year.
//returns a BookArray structure, where the field "array" is a newly allocated array of books, or null if no book with the 
//provided title can be found. The length of the array is also recorded in the returned structure, with 0 in case
//array is the null pointer.
BookArray find_book_by_year (unsigned int year);




